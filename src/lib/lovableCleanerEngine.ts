

import type { ScanResult, ScanIssue } from './lovablePatternScanner';

// ============= TYPES =============

export interface CleaningOptions {
  removeImports: boolean;
  replacePatterns: boolean;
  fixDependencies: boolean;
  generatePolyfills: boolean;
  preserveComments: boolean;
  dryRun: boolean;
}

export interface FileCleaningResult {
  filePath: string;
  originalContent: string;
  cleanedContent: string;
  wasModified: boolean;
  wasRemoved: boolean;
  changes: Change[];
  rewrites: Rewrite[];
}

export interface Change {
  type: 'removed' | 'replaced' | 'added';
  line: number;
  column: number;
  original: string;
  replacement: string;
  reason: string;
}

export interface Rewrite {
  type: 'import' | 'pattern' | 'dependency' | 'function' | 'component';
  original: string;
  suggested: string;
  description: string;
  autoApplicable: boolean;
}

export interface CleaningReport {
  totalFiles: number;
  filesModified: number;
  filesRemoved: number;
  filesUnchanged: number;
  totalChanges: number;
  totalRewrites: number;
  results: Map<string, FileCleaningResult>;
  cleanedFiles: Record<string, string>;
  packageJsonPatches: PackageJsonPatch[];
  summary: CleaningSummary;
}

export interface CleaningSummary {
  importsRemoved: number;
  patternsReplaced: number;
  dependenciesFixed: number;
  polyfillsGenerated: number;
  estimatedTimeSaved: number; // en minutes
}

export interface PackageJsonPatch {
  action: 'remove' | 'replace' | 'add';
  package: string;
  originalVersion?: string;
  newPackage?: string;
  newVersion?: string;
  reason: string;
}

// ============= REPLACEMENT MAPS =============

const IMPORT_REPLACEMENTS: Record<string, { replacement: string; description: string }> = {
  // [PLATFORM] imports
  '@lovable/core': { 
    replacement: '', 
    description: 'Supprimer - fonctionnalitÃ© non nÃ©cessaire' 
  },
  '@[PLATFORM]/ui': { 
    replacement: '@radix-ui/react-*', 
    description: 'Utiliser Radix UI directement' 
  },
  '[PLATFORM]-tagger': { 
    replacement: '', 
    description: 'Supprimer - outil de debug [PLATFORM]' 
  },
  
    '@/integrations/supabase/client': { 
    replacement: '@supabase/supabase-js', 
    description: 'Import direct Supabase' 
  },
  '@/integrations/supabase/types': { 
    replacement: './types/database.ts', 
    description: 'Types locaux gÃ©nÃ©rÃ©s' 
  },
  
  // Agent imports
  '@agent/': { 
    replacement: '', 
    description: 'Supprimer - agent [PLATFORM]' 
  },
  
  // AI SDK replacements
  '@anthropic-ai/sdk': { 
    replacement: '@/lib/unifiedLLM', 
    description: 'Utiliser UnifiedLLM souverain' 
  },
  'openai': { 
    replacement: '@/lib/unifiedLLM', 
    description: 'Utiliser UnifiedLLM souverain' 
  },
};

const PATTERN_REPLACEMENTS: Array<{
  pattern: RegExp;
  replacement: string | ((match: string, ...groups: string[]) => string);
  description: string;
}> = [
    {
    pattern: /[PLATFORM]\.generate\s*\(\s*(['"`])([^'"`]+)\1\s*\)/g,
    replacement: (_, quote, prompt) => `unifiedLLM.complete(${quote}${prompt}${quote})`,
    description: 'Remplacement par UnifiedLLM.complete()'
  },
  
  // lovableApi calls
  {
    pattern: /lovableApi\.(chat|complete|generate)\s*\(/g,
    replacement: 'unifiedLLM.$1(',
    description: 'Remplacement par UnifiedLLM'
  },
  
  // getAIAssistant
  {
    pattern: /getAIAssistant\s*\(\s*\)/g,
    replacement: 'new UnifiedLLM({ provider: "ollama" })',
    description: 'Remplacement par instance UnifiedLLM'
  },
  
  // runAssistant
  {
    pattern: /runAssistant\s*\(\s*([^)]+)\s*\)/g,
    replacement: 'await unifiedLLM.chat($1)',
    description: 'Remplacement par UnifiedLLM.chat()'
  },
  
  // EventSchema usage
  {
    pattern: /EventSchema\.(\w+)/g,
    replacement: (_, schemaName) => `z.object({ g,
    replacement: '',
    description: 'Suppression commentaires [PLATFORM]'
  },
  {
    pattern: /\/\/\s*Generated by Lovable[^\n]*/gi,
    replacement: '',
    description: 'Suppression commentaires gÃ©nÃ©ration'
  },
  
  // Supabase project URLs (hardcoded)
  {
    pattern: /https:\/\/[a-z]{20}\.supabase\.co/g,
    replacement: 'process.env.SUPABASE_URL',
    description: 'Remplacement par variable d\'environnement'
  },
  
  // Telemetry fetch calls
  {
    pattern: /fetch\s*\(\s*['"][^'"]*lovable[^'"]*['"]\s*[)]/gi,
    replacement: '',
    description: 'Suppression beacon tÃ©lÃ©mÃ©trie'
  },
  
  // Environment variables
  {
    pattern: /VITE_LOVABLE_[A-Z_]+/g,
    replacement: 'VITE_APP_CONFIG',
    description: 'Remplacement variable [PLATFORM]'
  }];

  cleanProject(
    files: Record<string, string>,
    scanResult: ScanResult
  ): CleaningReport {
    const results = new Map<string, FileCleaningResult>();
    const cleanedFiles: Record<string, string> = {};
    const packageJsonPatches: PackageJsonPatch[] = [];
    
    let filesModified = 0;
    let filesRemoved = 0;
    let filesUnchanged = 0;
    let totalChanges = 0;
    let totalRewrites = 0;
    
    const summary: CleaningSummary = {
      importsRemoved: 0,
      patternsReplaced: 0,
      dependenciesFixed: 0,
      polyfillsGenerated: 0,
      estimatedTimeSaved: 0
    };
    
    // Nettoyer chaque fichier
    for (const [filePath, content] of Object.entries(files)) {
      // Ignorer node_modules et fichiers binaires
      if (this.shouldSkipFile(filePath)) {
        cleanedFiles[filePath] = content;
        filesUnchanged++;
        continue;
      }
      
      // Trouver les issues pour ce fichier
      const fileIssues = scanResult.issues.filter(i => i.file === filePath);
      
      // Nettoyer le fichier
      const result = this.cleanFile(filePath, content, fileIssues);
      results.set(filePath, result);
      
      if (result.wasRemoved) {
        filesRemoved++;
      } else if (result.wasModified) {
        filesModified++;
        cleanedFiles[filePath] = result.cleanedContent;
      } else {
        filesUnchanged++;
        cleanedFiles[filePath] = content;
      }
      
      totalChanges += result.changes.length;
      totalRewrites += result.rewrites.length;
      
      // Compter les types de changements
      for (const change of result.changes) {
        if (change.reason.includes('import')) summary.importsRemoved++;
        if (change.reason.includes('pattern') || change.reason.includes('replacement')) summary.patternsReplaced++;
      }
      
      // Traitement spÃ©cial pour package.json
      if (filePath === 'package.json' || filePath.endsWith('/package.json')) {
        const patches = this.generatePackagePatches(content);
        packageJsonPatches.push(...patches);
        summary.dependenciesFixed += patches.length;
        
        // Appliquer les patches
        if (!this.options.dryRun && this.options.fixDependencies) {
          const patchedContent = this.applyPackagePatches(content, patches);
          cleanedFiles[filePath] = patchedContent;
        }
      }
    }
    
    // GÃ©nÃ©rer les polyfills si nÃ©cessaire
    if (this.options.generatePolyfills) {
      const polyfills = this.generatePolyfills(scanResult);
      for (const [path, content] of Object.entries(polyfills)) {
        cleanedFiles[path] = content;
        summary.polyfillsGenerated++;
      }
    }
    
    // Estimer le temps Ã©conomisÃ© (basÃ© sur le nombre de changements)
    summary.estimatedTimeSaved = Math.ceil((totalChanges * 0.5) + (totalRewrites * 2));
    
    return {
      totalFiles: Object.keys(files).length,
      filesModified,
      filesRemoved,
      filesUnchanged,
      totalChanges,
      totalRewrites,
      results,
      cleanedFiles,
      packageJsonPatches,
      summary
    };
  }
  
  
  private cleanImports(content: string, filePath: string): {
    content: string;
    modified: boolean;
    changes: Change[];
    rewrites: Rewrite[];
  } {
    const lines = content.split('\n');
    const cleanedLines: string[] = [];
    const changes: Change[] = [];
    const rewrites: Rewrite[] = [];
    let modified = false;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      let shouldKeep = true;
      let replacementLine = line;
      
      // VÃ©rifier chaque pattern d'import
      for (const [importPattern, replacement] of Object.entries(IMPORT_REPLACEMENTS)) {
        if (line.includes(importPattern)) {
          if (replacement.replacement === '') {
            // Supprimer la ligne
            shouldKeep = false;
            changes.push({
              type: 'removed',
              line: i + 1,
              column: 1,
              original: line,
              replacement: '',
              reason: `Import propriÃ©taire supprimÃ©: ${importPattern}`
            });
          } else {
            // Remplacer l'import
            replacementLine = line.replace(importPattern, replacement.replacement);
            changes.push({
              type: 'replaced',
              line: i + 1,
              column: line.indexOf(importPattern) + 1,
              original: line,
              replacement: replacementLine,
              reason: `Import remplacÃ©: ${replacement.description}`
            });
            
            rewrites.push({
              type: 'import',
              original: importPattern,
              suggested: replacement.replacement,
              description: replacement.description,
              autoApplicable: true
            });
          }
          modified = true;
          break;
        }
      }
      
      if (shouldKeep) {
        cleanedLines.push(replacementLine);
      }
    }
    
    return {
      content: cleanedLines.join('\n'),
      modified,
      changes,
      rewrites
    };
  }
  
  
  private replacePatterns(content: string, filePath: string): {
    content: string;
    modified: boolean;
    changes: Change[];
    rewrites: Rewrite[];
  } {
    let cleanedContent = content;
    const changes: Change[] = [];
    const rewrites: Rewrite[] = [];
    let modified = false;
    
    for (const patternDef of PATTERN_REPLACEMENTS) {
      // Reset regex
      patternDef.pattern.lastIndex = 0;
      
      let match: RegExpExecArray | null;
      const matches: Array<{ index: number; text: string }> = [];
      
      // Collecter tous les matches d'abord
      while ((match = patternDef.pattern.exec(content)) !== null) {
        matches.push({ index: match.index, text: match[0] });
      }
      
      if (matches.length > 0) {
        modified = true;
        
        // Appliquer le remplacement
        if (typeof patternDef.replacement === 'function') {
          cleanedContent = cleanedContent.replace(patternDef.pattern, patternDef.replacement as any);
        } else {
          cleanedContent = cleanedContent.replace(patternDef.pattern, patternDef.replacement);
        }
        
        // Enregistrer les changements
        for (const m of matches) {
          const { line, column } = this.getLineAndColumn(content, m.index);
          changes.push({
            type: 'replaced',
            line,
            column,
            original: m.text,
            replacement: typeof patternDef.replacement === 'string' ? patternDef.replacement : '[computed]',
            reason: patternDef.description
          });
        }
        
        rewrites.push({
          type: 'pattern',
          original: patternDef.pattern.source,
          suggested: typeof patternDef.replacement === 'string' ? patternDef.replacement : '[function]',
          description: patternDef.description,
          autoApplicable: true
        });
      }
    }
    
    return {
      content: cleanedContent,
      modified,
      changes,
      rewrites
    };
  }
  
  
  private generateUnifiedLLMPolyfill(): string {
    return `
  private cleanEmptyLines(content: string): string {
    return content.replace(/\n{3,}/g, '\n\n');
  }
  
  
export function formatCleaningReport(report: CleaningReport): string {
  const lines: string[] = [
    'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
    '           INOPAY CLEANER ENGINE REPORT                    ',
    'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
    '',
    `ğŸ“ Fichiers traitÃ©s: ${report.totalFiles}`,
    `âœï¸  Fichiers modifiÃ©s: ${report.filesModified}`,
    `ğŸ—‘ï¸  Fichiers supprimÃ©s: ${report.filesRemoved}`,
    `âœ… Fichiers inchangÃ©s: ${report.filesUnchanged}`,
    '',
    'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€',
    '                       RÃ‰SUMÃ‰                              ',
    'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€',
    `ğŸ“¦ Imports supprimÃ©s: ${report.summary.importsRemoved}`,
    `ğŸ”„ Patterns remplacÃ©s: ${report.summary.patternsReplaced}`,
    `ğŸ“‹ DÃ©pendances corrigÃ©es: ${report.summary.dependenciesFixed}`,
    `ğŸ”§ Polyfills gÃ©nÃ©rÃ©s: ${report.summary.polyfillsGenerated}`,
    `â±ï¸  Temps estimÃ© Ã©conomisÃ©: ${report.summary.estimatedTimeSaved} min`,
    ''];
  
  if (report.packageJsonPatches.length > 0) {
    lines.push('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    lines.push('                 PATCHES PACKAGE.JSON                      ');
    lines.push('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    
    for (const patch of report.packageJsonPatches) {
      const icon = patch.action === 'remove' ? 'ğŸ—‘ï¸' : patch.action === 'replace' ? 'ğŸ”„' : 'â•';
      lines.push(`${icon} ${patch.action.toUpperCase()}: ${patch.package}`);
      if (patch.newPackage) {
        lines.push(`   â†’ ${patch.newPackage}@${patch.newVersion}`);
      }
      lines.push(`   ğŸ“ ${patch.reason}`);
    }
    lines.push('');
  }
  
  lines.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  lines.push('            GÃ©nÃ©rÃ© par Inopay Cleaner Engine               ');
  lines.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  
  return lines.join('\n');
}

// Default export
export default LovableCleanerEngine;

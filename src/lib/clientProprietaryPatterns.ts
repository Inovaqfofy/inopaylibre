
export function cleanExternalAssetUrls(content: string, filePath: string): {
  cleaned: string;
  changes: string[];
  assetsToDownload: { originalUrl: string; localPath: string }[];
} {
  const changes: string[] = [];
  const assetsToDownload: { originalUrl: string; localPath: string }[] = [];
  let cleaned = content;

  // Pattern to match URLs in various contexts (src="", url(), href="", etc.)
  for (const [domain, localBase] of Object.entries(EXTERNAL_ASSET_REPLACEMENTS)) {
    const escapedDomain = domain.replace(/\./g, '\\.');
    
    // Match full URLs with protocol
    const urlPatterns = [
      // src=""
      new RegExp(`(["'\`])https?://[^"'\`]*${escapedDomain}/([^"'\`]+)(["'\`])`, 'gi""url\\(\\s*["']?https?://[^)]*${escapedDomain}/([^)]+)["']?\\s*\\)`, 'gi')];

    for (const pattern of urlPatterns) {
      const matches = cleaned.matchAll(pattern);
      for (const match of matches) {
        const originalUrl = match[0];
        // Extract just the filename/path portion
        const urlMatch = originalUrl.match(/\/([^\/?"'`\s]+(?:\.[a-zA-Z0-9]+))(?:[?"'\s\)]|$)/);
        if (urlMatch) {
          const filename = urlMatch[1];
          const localPath = `${localBase}/${filename}`;
          
          // Only process image/asset files
          if (/\.(png|jpg|jpeg|gif|svg|webp|ico|pdf|mp4|mp3|woff|woff2|ttf|eot)$/i.test(filename)) {
            assetsToDownload.push({ 
              originalUrl: originalUrl.replace(/^["'\`]|["'\`]$/g, '').replace(/^url\(["']?|["']?\)$/g, ''),
              localPath 
            });
          }
        }
      }
    }

    // Replace URLs with local paths
    // Pattern 1: src/href attributes
    const attrPattern = new RegExp(
      `(src|href|poster|srcset)\\s*=\\s*(["'\`])https?://[^"'\`]*${escapedDomain}/[^"'\`]*?([^/"'\`]+\\.[a-zA-Z0-9]+)(["'\`])`,
      'gi'
    );
    const beforeAttr = cleaned;
    cleaned = cleaned.replace(attrPattern, `$1=$2${localBase}/$3$4`);
    if (cleaned !== beforeAttr) {
      changes.push(`URL ${domain} remplacée par chemin local dans attribut`);
    }

    // Pattern 2: CSS url()
    const cssPattern = new RegExp(
      `url\\(\\s*["']?https?://[^)]*${escapedDomain}/[^)]*?([^/)]+\\.[a-zA-Z0-9]+)["']?\\s*\\)`,
      'gi'
    );
    const beforeCss = cleaned;
    cleaned = cleaned.replace(cssPattern, `url('${localBase}/$1')`);
    if (cleaned !== beforeCss) {
      changes.push(`URL ${domain} remplacée par chemin local dans CSS`);
    }

    // Pattern 3: Template strings or JS strings
    const stringPattern = new RegExp(
      `(["'\`])https?://[^"'\`]*${escapedDomain}/[^"'\`]*?([^/"'\`]+\\.[a-zA-Z0-9]+)(["'\`])`,
      'gi'
    );
    const beforeString = cleaned;
    cleaned = cleaned.replace(stringPattern, `$1${localBase}/$2$3`);
    if (cleaned !== beforeString) {
      changes.push(`URL ${domain} remplacée par chemin local dans string`);
    }
  }

  return { cleaned, changes, assetsToDownload };
}

// ============= AUTO-POLYFILL DEFINITIONS =============

export const HOOK_POLYFILLS: Record<string, { filename: string; content: string }> = {
  'use-mobile': {
    filename: 'use-mobile.ts',
    content: `import { useState, useEffect } from 'react';

');
    if (cleaned !== before) {
      suspiciousPatterns.push(`Appel suspect supprimé: ${name}`);
      changes.push(`Télémétrie supprimée: ${name}`);
    }
  }

  // ========== PASS 9: Remove VITE_ env vars that are proprietary ==========
  const envVarPatterns = [
    { pattern: /import\.meta\.env\.VITE_LOVABLE_[A-Z_]+/g, name: 'VITE_LOVABLE_*' },
    { pattern: /import\.meta\.env\.VITE_GPT_[A-Z_]+/g, name: 'VITE_GPT_*' },
    { pattern: /process\.env\.VITE_LOVABLE_[A-Z_]+/g, name: 'process.env VITE_LOVABLE_*' },
    { pattern: /process\.env\.VITE_GPT_[A-Z_]+/g, name: 'process.env VITE_GPT_*' }];

  for (const { pattern, name } of envVarPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, '""');
    if (cleaned !== before) {
      changes.push(`Variable env supprimée: ${name}`);
    }
  }

  // ========== PASS 10: Remove proprietary comments (comprehensive) ==========
  const commentPatterns = [
    { pattern: /\/\/\s*@lovable[^\n]*\n?/gi, name: '@[PLATFORM] comment' },
    { pattern: /\/\/\s*@[PLATFORM][^\n]*\n?/gi, name: '@gptengineer comment' },
    { pattern: /\/\/\s*Generated by [PLATFORM][^\n]*\n?/gi, name: 'Generated by Lovable' },
    { pattern: /\/\/\s*Built with [PLATFORM][^\n]*\n?/gi, name: 'Built with Lovable' },
    { pattern: /\/\/\s*Created with GPT Engineer[^\n]*\n?/gi, name: 'Created with GPT Engineer' },
    { pattern: /\/\*\s*@[PLATFORM][\s\S]*?\*\    { pattern: /\/\*\s*@[PLATFORM][\s\S]*?\*\    { pattern: //gi, name: '[PLATFORM] HTML comment' },
    { pattern: //gi, '');
  cleaned = cleaned.replace(//gi, '');
  
  if (cleaned !== before) {
    changes.push('index.html nettoyé des scripts et attributs propriétaires');
  }
  
  return { cleaned, changes };
}

export function cleanTsConfig(content: string): { cleaned: string; changes: string[] } {
  const changes: string[] = [];
  
  try {
    const config = JSON.parse(content);
    
    // Remove paths pointing to integrations
    if (config.compilerOptions?.paths) {
      const pathsToRemove = Object.keys(config.compilerOptions.paths).filter(
        key => key.includes('integrations') || key.includes('[PLATFORM]') || key.includes('[PLATFORM]')
      );
      
      for (const path of pathsToRemove) {
        delete config.compilerOptions.paths[path];
        changes.push(`Path supprimé: ${path}`);
      }
    }
    
    // Remove include patterns for integrations
    if (Array.isArray(config.include)) {
      config.include = config.include.filter(
        (inc: string) => !inc.includes('integrations') && !inc.includes('[PLATFORM]')
      );
    }
    
    return { cleaned: JSON.stringify(config, null, 2), changes };
  } catch (e) {
    return { cleaned: content, changes };
  }
}

gi, 'https://your-domain.com');
  cleaned = cleaned.replace(/https?:\/\/[^\s]*[PLATFORM]\.(app|run)[^\s]*/gi, 'https://your-domain.com');
  
  // Replace JWT tokens (keeping structure but replacing value)
  cleaned = cleaned.replace(/eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g, 'your-jwt-token');
  
  if (cleaned !== before) {
    changes.push('Variables .env nettoyées des IDs hardcodés');
  }
  
  return { cleaned, changes, wasModified: changes.length > 0, suspiciousPatterns: [] };
}

gi, 'https://your-app-url.com');
  cleaned = cleaned.replace(/https?:\/\/[^\s)\]]*[PLATFORM]\.(app|run)[^\s)\]]*/gi, 'https://your-app-url.com');
  
  // Replace hardcoded Supabase project IDs
  cleaned = cleaned.replace(/izqveyvcebolrqpqlmho/gi, 'your-project-id');
  cleaned = cleaned.replace(/[a-z]{20,30}\.supabase\.co/gi, 'your-project-id.supabase.co');
  
  // Remove "Made with [PLATFORM]" badges
  cleaned = cleaned.replace(/\[!\[.*?lovable.*?\]\(.*?\)\]\(.*?\)/gi, '');
  cleaned = cleaned.replace(/\[!\[.*?[PLATFORM].*?\]\(.*?\)\]\(.*?\)/gi, '');
  
  // Remove "Built with" lines
  cleaned = cleaned.replace(/^.*built with.*lovable.*$/gim, '');
  cleaned = cleaned.replace(/^.*made with.*[PLATFORM].*$/gim, '');
  cleaned = cleaned.replace(/^.*powered by.*[PLATFORM].*$/gim, '');
  
  // Remove data-lov attributes mentioned in markdown
  cleaned = cleaned.replace(/data-lov[a-z-]*="[^"]*"/gi, '');
  
  // Replace JWT tokens
  cleaned = cleaned.replace(/eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g, 'your-jwt-token');
  
  // Clean up empty lines
  cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
  
  if (cleaned !== before) {
    changes.push('README nettoyé des références propriétaires');
  }
  
  return { cleaned, changes, wasModified: changes.length > 0, suspiciousPatterns: [] };
}

gi, '${APP_URL}');
  
  // Replace JWT tokens
  cleaned = cleaned.replace(/eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g, '${JWT_TOKEN}');
  
  if (cleaned !== before) {
    changes.push('Script shell nettoyé des IDs hardcodés');
  }
  
  return { cleaned, changes, wasModified: changes.length > 0, suspiciousPatterns: [] };
}

export function generateEnvExample(files: Map<string, string>): string {
  const envVars = new Set<string>();
  
  for (const [ content] of files) {
    // Match VITE_ and REACT_APP_ environment variables
    const matches = content.matchAll(/(?:import\.meta\.env\.|process\.env\.)(VITE_[A-Z_]+|REACT_APP_[A-Z_]+)/g);
    for (const match of matches) {
      // Skip proprietary env vars
      if (!match[1].includes('[PLATFORM]') && !match[1].includes('GPT') && !match[1].includes('PROJECT_ID')) {
        envVars.add(match[1]);
      }
    }
  }
  
  // Always include essential Supabase vars
  envVars.add('VITE_SUPABASE_URL');
  envVars.add('VITE_SUPABASE_ANON_KEY');
  
  let result = `# Variables d'environnement - Généré par Inopay Liberation
# Configurez ces valeurs avec votre propre infrastructure

# === SUPABASE (ou votre base de données) ===
VITE_SUPABASE_URL=https://your-project.supabase.co
VITE_SUPABASE_ANON_KEY=your-anon-key

`;
  
  for (const v of envVars) {
    if (!v.includes('SUPABASE')) {
      result += `${v}=\n`;
    }
  }
  
  return result;
}

export function finalVerificationPass(
  cleanedFiles: Record<string, string>
): { isClean: boolean; remainingIssues: string[]; criticalCount: number } {
  const remainingIssues: string[] = [];
  let criticalCount = 0;
  
  for (const [path, content] of Object.entries(cleanedFiles)) {
    // Skip non-source files
    if (!path.match(/\.(ts|tsx|js|jsx|json|html|css|scss)$/)) continue;
    
    // Skip patterns files (they legitimately contain these patterns for detection)
    if (path.includes('clientProprietaryPatterns') || path.includes('proprietary-patterns')) continue;
    if (path.includes('security-cleaner')) continue;
    
    // Check for any remaining proprietary references with CONTEXTUAL detection
    const criticalPatterns = [
      { 
        pattern: /import\s+[^;]*from\s*['"]@\/integrations\/supabase/g, 
        name: 'Import Supabase auto-généré' 
      },
      { 
        // Only match domains in URL context, not just any text
        pattern: /(?:https?:)?\/\/[^\s'"]*(?:lovable\.app|lovable\.dev|gptengineer\.app)/gi, 
        name: 'URL [PLATFORM]' 
      },
      { 
        pattern: /izqveyvcebolrqpqlmho/g, 
        name: 'ID projet Supabase' 
      },
      { 
        // JWT tokens (but not in patterns/test files)
        pattern: /['"]eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+['"]/g, 
        name: 'Token JWT hardcodé' 
      }];
    
    for (const { pattern, name } of criticalPatterns) {
      // Reset regex lastIndex
      pattern.lastIndex = 0;
      if (pattern.test(content)) {
        remainingIssues.push(`${path}: ${name}`);
        criticalCount++;
      }
    }
  }
  
  return {
    isClean: remainingIssues.length === 0,
    remainingIssues,
    criticalCount,
  };
}

// ============================================
// CENTRALIZED POLYFILLS V2 - Clean file-based approach
// These are generated as separate files, not injected inline
// ============================================

', name: 'telemetry.track' },
    { pattern: /analytics\s*\.\s*track\s*\([^)]*\)/gi, replacement: 'g, replacement: 'interface IRenamedType', name: '[PLATFORM] interface' },
    { pattern: /type\s+\w*[Ll]ovable\w*\s*=/g, replacement: 'type RenamedType =', name: '[PLATFORM] type' }];

  if (!isConfigFile) {
    for (const { pattern, replacement, name } of proprietaryIdentifiers) {
      const before = cleaned;
      cleaned = cleaned.replace(pattern, replacement);
      if (cleaned !== before) {
        purgedPatterns.push(name);
      }
    }
  }

  // === CATÉGORIE 4: URLs et domaines propriétaires dans le code ===
  const proprietaryUrls = [
        { pattern: /https?:\/\/[a-z0-9-]+\.lovableproject\.com[^\s'"`]*/gi, replacement: 'https://your-domain.com', name: 'lovableproject URL' },
    { pattern: /https?:\/\/[a-z0-9-]+\.[PLATFORM]\.(app|dev)[^\s'"`]*/gi, replacement: 'https://your-domain.com', name: '[PLATFORM] URL' },
    { pattern: /https?:\/\/[a-z0-9-]+\.[PLATFORM]\.(app|run)[^\s'"`]*/gi, replacement: 'https://your-domain.com', name: '[PLATFORM] URL' },
    // API endpoints AI
    { pattern: /https?:\/\/api\.openai\.com[^\s'"`]*/gi, replacement: '${OLLAMA_BASE_URL}/api', name: 'OpenAI API URL' },
    { pattern: /https?:\/\/api\.anthropic\.com[^\s'"`]*/gi, replacement: '${OLLAMA_BASE_URL}/api', name: 'Anthropic API URL' },
        { pattern: /https?:\/\/ai\.gateway\.[PLATFORM]\.dev[^\s'"`]*/gi, replacement: '${OLLAMA_BASE_URL}/api', name: '[PLATFORM] AI Gateway' }];

  for (const { pattern, replacement, name } of proprietaryUrls) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, replacement);
    if (cleaned !== before) {
      purgedPatterns.push(name);
    }
  }

  // === CATÉGORIE 5: Clés API et secrets hardcodés ===
  const hardcodedSecrets = [
    // OpenAI API keys
    { pattern: /sk-[a-zA-Z0-9]{20,}/g, replacement: 'YOUR_OPENAI_KEY', name: 'OpenAI API key' },
    // Anthropic API keys
    { pattern: /sk-ant-[a-zA-Z0-9-]{20,}/g, replacement: 'YOUR_ANTHROPIC_KEY', name: 'Anthropic API key' },
    // Replicate tokens
    { pattern: /r8_[a-zA-Z0-9]{30,}/g, replacement: 'YOUR_REPLICATE_TOKEN', name: 'Replicate token' },
    // HuggingFace tokens
    { pattern: /hf_[a-zA-Z0-9]{30,}/g, replacement: 'YOUR_HUGGINGFACE_TOKEN', name: 'HuggingFace token' },
    // [PLATFORM] API keys
    { pattern: /lov_[a-zA-Z0-9]{20,}/g, replacement: 'YOUR_API_KEY', name: '[PLATFORM] API key' },
    // Generic API key patterns
    { pattern: /AI_API_KEY/g, replacement: 'AI_API_KEY', name: 'AI_API_KEY env var' }];

  for (const { pattern, replacement, name } of hardcodedSecrets) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, replacement);
    if (cleaned !== before) {
      purgedPatterns.push(name);
    }
  }

  // === CATÉGORIE 6: Commentaires avec mentions propriétaires ===
  const proprietaryComments = [
    // Commentaires mentionnant des plateformes
    { pattern: /\/\/\s*[^\n]*\b([PLATFORM]|[PLATFORM]|bolt\.new)\b[^\n]*\n/gi, replacement: '', name: 'platform comment' },
    { pattern: /\/\*[\s\S]*?\b([PLATFORM]|[PLATFORM])\b[\s\S]*?\*\//gi, replacement: '', name: 'platform block comment' },
    // Commentaires "powered by"
    { pattern: /\/\/\s*[Pp]owered by[^\n]*\n/g, replacement: '', name: 'powered by comment' },
    { pattern: /\/\/\s*[Bb]uilt with[^\n]*\n/g, replacement: '', name: 'built with comment' },
    { pattern: /\/\/\s*[Mm]ade with[^\n]*\n/g, replacement: '', name: 'made with comment' },
    { pattern: /\/\/\s*[Cc]reated with[^\n]*\n/g, replacement: '', name: 'created with comment' },
    { pattern: /\/\/\s*[Gg]enerated by[^\n]*\n/g, replacement: '', name: 'generated by comment' }];

  for (const { pattern, replacement, name } of proprietaryComments) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, replacement);
    if (cleaned !== before) {
      purgedPatterns.push(name);
    }
  }

  // === CATÉGORIE 7: Imports de SDKs propriétaires ===
  const proprietaryImports = [
    // AI SDKs
    { pattern: /import\s+[^;]*from\s*['"]openai['"]\s*;?\n?/g, replacement: '// REMOVED: OpenAI import - use Ollama\n', name: 'openai import' },
    { pattern: /import\s+[^;]*from\s*['"]@anthropic-ai\/sdk['"]\s*;?\n?/g, replacement: '// REMOVED: Anthropic import - use Ollama\n', name: 'anthropic import' },
    { pattern: /import\s+[^;]*from\s*['"]replicate['"]\s*;?\n?/g, replacement: '// REMOVED: Replicate import - use local models\n', name: 'replicate import' },
    { pattern: /import\s+[^;]*from\s*['"]@huggingface\/inference['"]\s*;?\n?/g, replacement: '// REMOVED: HuggingFace import - use local models\n', name: 'huggingface import' },
    { pattern: /import\s+[^;]*from\s*['"]ai['"]\s*;?\n?/g, replacement: '// REMOVED: ai-sdk import - use fetch\n', name: 'ai-sdk import' },
    // [PLATFORM] gateway
    { pattern: /import\s+[^;]*from\s*['"]@lovable\/[^'"]*['"]\s*;?\n?/g, replacement: '', name: '@[PLATFORM] import' }];

  for (const { pattern, replacement, name } of proprietaryImports) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, replacement);
    if (cleaned !== before) {
      purgedPatterns.push(name);
    }
  }

  // === Nettoyage final: lignes vides multiples ===
  cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
  cleaned = cleaned.replace(/^\s*\/\/ REMOVED:[^\n]*\n(\s*\/\/ REMOVED:[^\n]*\n)+/gm, '// REMOVED: multiple proprietary imports\n');

  return {
    cleaned,
    purgedPatterns,
    wasModified: cleaned !== originalContent
  };
}

/**
 * Exécute la purge finale sur tous les fichiers source
 */
export function executeFinalSovereigntyPurge(files: Record<string, string>): {
  cleanedFiles: Record<string, string>;
  purgeReport: { file: string; patterns: string[] }[];
  totalPatternsPurged: number;
} {
  const cleanedFiles: Record<string, string> = {};
  const purgeReport: { file: string; patterns: string[] }[] = [];
  let totalPatternsPurged = 0;

  for (const [filePath, content] of Object.entries(files)) {
    // Ignorer les fichiers binaires et certains fichiers de config
    if (
      filePath.endsWith('.png') || 
      filePath.endsWith('.jpg') || 
      filePath.endsWith('.ico') ||
      filePath.endsWith('.woff') ||
      filePath.endsWith('.woff2') ||
      filePath.includes('node_modules/') ||
      filePath.includes('.git/')
    ) {
      cleanedFiles[filePath] = content;
      continue;
    }

    // Appliquer la purge finale
    const result = purgeProprietaryMentions(content, filePath);
    cleanedFiles[filePath] = result.cleaned;

    if (result.purgedPatterns.length > 0) {
      purgeReport.push({ file: filePath, patterns: result.purgedPatterns });
      totalPatternsPurged += result.purgedPatterns.length;
    }
  }

  return { cleanedFiles, purgeReport, totalPatternsPurged };
}


export function cleanExternalAssetUrls(content: string, filePath: string): {
  cleaned: string;
  changes: string[];
  assetsToDownload: { originalUrl: string; localPath: string }[];
} {
  const changes: string[] = [];
  const assetsToDownload: { originalUrl: string; localPath: string }[] = [];
  let cleaned = content;

  // Pattern to match URLs in various contexts (src="", url(), href="", etc.)
  for (const [domain, localBase] of Object.entries(EXTERNAL_ASSET_REPLACEMENTS)) {
    const escapedDomain = domain.replace(/\./g, '\\.');
    
    // Match full URLs with protocol
    const urlPatterns = [
      // src=""
      new RegExp(`(["'\`])https?://[^"'\`]*${escapedDomain}/([^"'\`]+)(["'\`])`, 'gi""url\\(\\s*["']?https?://[^)]*${escapedDomain}/([^)]+)["']?\\s*\\)`, 'gi')];

    for (const pattern of urlPatterns) {
      const matches = cleaned.matchAll(pattern);
      for (const match of matches) {
        const originalUrl = match[0];
        // Extract just the filename/path portion
        const urlMatch = originalUrl.match(/\/([^\/?"'`\s]+(?:\.[a-zA-Z0-9]+))(?:[?"'\s\)]|$)/);
        if (urlMatch) {
          const filename = urlMatch[1];
          const localPath = `${localBase}/${filename}`;
          
          // Only process image/asset files
          if (/\.(png|jpg|jpeg|gif|svg|webp|ico|pdf|mp4|mp3|woff|woff2|ttf|eot)$/i.test(filename)) {
            assetsToDownload.push({ 
              originalUrl: originalUrl.replace(/^["'\`]|["'\`]$/g, '').replace(/^url\(["']?|["']?\)$/g, ''),
              localPath 
            });
          }
        }
      }
    }

    // Replace URLs with local paths
    // Pattern 1: src/href attributes
    const attrPattern = new RegExp(
      `(src|href|poster|srcset)\\s*=\\s*(["'\`])https?://[^"'\`]*${escapedDomain}/[^"'\`]*?([^/"'\`]+\\.[a-zA-Z0-9]+)(["'\`])`,
      'gi'
    );
    const beforeAttr = cleaned;
    cleaned = cleaned.replace(attrPattern, `$1=$2${localBase}/$3$4`);
    if (cleaned !== beforeAttr) {
      changes.push(`URL ${domain} remplacée par chemin local dans attribut`);
    }

    // Pattern 2: CSS url()
    const cssPattern = new RegExp(
      `url\\(\\s*["']?https?://[^)]*${escapedDomain}/[^)]*?([^/)]+\\.[a-zA-Z0-9]+)["']?\\s*\\)`,
      'gi'
    );
    const beforeCss = cleaned;
    cleaned = cleaned.replace(cssPattern, `url('${localBase}/$1')`);
    if (cleaned !== beforeCss) {
      changes.push(`URL ${domain} remplacée par chemin local dans CSS`);
    }

    // Pattern 3: Template strings or JS strings
    const stringPattern = new RegExp(
      `(["'\`])https?://[^"'\`]*${escapedDomain}/[^"'\`]*?([^/"'\`]+\\.[a-zA-Z0-9]+)(["'\`])`,
      'gi'
    );
    const beforeString = cleaned;
    cleaned = cleaned.replace(stringPattern, `$1${localBase}/$2$3`);
    if (cleaned !== beforeString) {
      changes.push(`URL ${domain} remplacée par chemin local dans string`);
    }
  }

  return { cleaned, changes, assetsToDownload };
}

// ============= AUTO-POLYFILL DEFINITIONS =============

export const HOOK_POLYFILLS: Record<string, { filename: string; content: string }> = {
  'use-mobile': {
    filename: 'use-mobile.ts',
    content: `import { useState, useEffect } from 'react';

');
    if (cleaned !== before) {
      suspiciousPatterns.push(`Appel suspect supprimé: ${name}`);
      changes.push(`Télémétrie supprimée: ${name}`);
    }
  }

  // ========== PASS 9: Remove VITE_ env vars that are proprietary ==========
  const envVarPatterns = [
    { pattern: /import\.meta\.env\.VITE_LOVABLE_[A-Z_]+/g, name: 'VITE_LOVABLE_*' },
    { pattern: /import\.meta\.env\.VITE_GPT_[A-Z_]+/g, name: 'VITE_GPT_*' },
    { pattern: /process\.env\.VITE_LOVABLE_[A-Z_]+/g, name: 'process.env VITE_LOVABLE_*' },
    { pattern: /process\.env\.VITE_GPT_[A-Z_]+/g, name: 'process.env VITE_GPT_*' }];

  for (const { pattern, name } of envVarPatterns) {
    const before = cleaned;
    cleaned = cleaned.replace(pattern, '""');
    if (cleaned !== before) {
      changes.push(`Variable env supprimée: ${name}`);
    }
  }

  // ========== PASS 10: Remove proprietary comments (comprehensive) ==========
  const commentPatterns = [
    { pattern: /\/\/\s*@lovable[^\n]*\n?/gi, name: '@lovable comment' },
    { pattern: /\/\/\s*@gptengineer[^\n]*\n?/gi, name: '@gptengineer comment' },
    { pattern: /\/\/\s*Generated by Lovable[^\n]*\n?/gi, name: 'Generated by Lovable' },
    { pattern: /\/\/\s*Built with Lovable[^\n]*\n?/gi, name: 'Built with Lovable' },
    { pattern: /\/\/\s*Created with GPT Engineer[^\n]*\n?/gi, name: 'Created with GPT Engineer' },
    { pattern: /\/\*\s*@lovable[\s\S]*?\*\//gi, name: '@lovable block' },
    { pattern: /\/\*\s*@gptengineer[\s\S]*?\*\//gi, name: '@gptengineer block' },
    { pattern: //gi, name: 'lovable HTML comment' },
    { pattern: //gi, '');
  cleaned = cleaned.replace(//gi, '');
  
  if (cleaned !== before) {
    changes.push('index.html nettoyé des scripts et attributs propriétaires');
  }
  
  return { cleaned, changes };
}

export function cleanTsConfig(content: string): { cleaned: string; changes: string[] } {
  const changes: string[] = [];
  
  try {
    const config = JSON.parse(content);
    
    // Remove paths pointing to integrations
    if (config.compilerOptions?.paths) {
      const pathsToRemove = Object.keys(config.compilerOptions.paths).filter(
        key => key.includes('integrations') || key.includes('lovable') || key.includes('gptengineer')
      );
      
      for (const path of pathsToRemove) {
        delete config.compilerOptions.paths[path];
        changes.push(`Path supprimé: ${path}`);
      }
    }
    
    // Remove include patterns for integrations
    if (Array.isArray(config.include)) {
      config.include = config.include.filter(
        (inc: string) => !inc.includes('integrations') && !inc.includes('lovable')
      );
    }
    
    return { cleaned: JSON.stringify(config, null, 2), changes };
  } catch (e) {
    return { cleaned: content, changes };
  }
}

gi, 'https://your-domain.com');
  cleaned = cleaned.replace(/https?:\/\/[^\s]*gptengineer\.(app|run)[^\s]*/gi, 'https://your-domain.com');
  
  // Replace JWT tokens (keeping structure but replacing value)
  cleaned = cleaned.replace(/eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g, 'your-jwt-token');
  
  if (cleaned !== before) {
    changes.push('Variables .env nettoyées des IDs hardcodés');
  }
  
  return { cleaned, changes, wasModified: changes.length > 0, suspiciousPatterns: [] };
}

gi, 'https://your-app-url.com');
  cleaned = cleaned.replace(/https?:\/\/[^\s)\]]*gptengineer\.(app|run)[^\s)\]]*/gi, 'https://your-app-url.com');
  
  // Replace hardcoded Supabase project IDs
  cleaned = cleaned.replace(/izqveyvcebolrqpqlmho/gi, 'your-project-id');
  cleaned = cleaned.replace(/[a-z]{20,30}\.supabase\.co/gi, 'your-project-id.supabase.co');
  
  // Remove "Made with Lovable" badges
  cleaned = cleaned.replace(/\[!\[.*?lovable.*?\]\(.*?\)\]\(.*?\)/gi, '');
  cleaned = cleaned.replace(/\[!\[.*?gptengineer.*?\]\(.*?\)\]\(.*?\)/gi, '');
  
  // Remove "Built with" lines
  cleaned = cleaned.replace(/^.*built with.*lovable.*$/gim, '');
  cleaned = cleaned.replace(/^.*made with.*lovable.*$/gim, '');
  cleaned = cleaned.replace(/^.*powered by.*lovable.*$/gim, '');
  
  // Remove data-lov attributes mentioned in markdown
  cleaned = cleaned.replace(/data-lov[a-z-]*="[^"]*"/gi, '');
  
  // Replace JWT tokens
  cleaned = cleaned.replace(/eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g, 'your-jwt-token');
  
  // Clean up empty lines
  cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
  
  if (cleaned !== before) {
    changes.push('README nettoyé des références propriétaires');
  }
  
  return { cleaned, changes, wasModified: changes.length > 0, suspiciousPatterns: [] };
}

gi, '${APP_URL}');
  
  // Replace JWT tokens
  cleaned = cleaned.replace(/eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g, '${JWT_TOKEN}');
  
  if (cleaned !== before) {
    changes.push('Script shell nettoyé des IDs hardcodés');
  }
  
  return { cleaned, changes, wasModified: changes.length > 0, suspiciousPatterns: [] };
}

export function generateEnvExample(files: Map<string, string>): string {
  const envVars = new Set<string>();
  
  for (const [ content] of files) {
    // Match VITE_ and REACT_APP_ environment variables
    const matches = content.matchAll(/(?:import\.meta\.env\.|process\.env\.)(VITE_[A-Z_]+|REACT_APP_[A-Z_]+)/g);
    for (const match of matches) {
      // Skip proprietary env vars
      if (!match[1].includes('LOVABLE') && !match[1].includes('GPT') && !match[1].includes('PROJECT_ID')) {
        envVars.add(match[1]);
      }
    }
  }
  
  // Always include essential Supabase vars
  envVars.add('VITE_SUPABASE_URL');
  envVars.add('VITE_SUPABASE_ANON_KEY');
  
  let result = `# Variables d'environnement - Généré par Inopay Liberation
# Configurez ces valeurs avec votre propre infrastructure

# === SUPABASE (ou votre base de données) ===
VITE_SUPABASE_URL=https://your-project.supabase.co
VITE_SUPABASE_ANON_KEY=your-anon-key

`;
  
  for (const v of envVars) {
    if (!v.includes('SUPABASE')) {
      result += `${v}=\n`;
    }
  }
  
  return result;
}

export function finalVerificationPass(
  cleanedFiles: Record<string, string>
): { isClean: boolean; remainingIssues: string[]; criticalCount: number } {
  const remainingIssues: string[] = [];
  let criticalCount = 0;
  
  for (const [path, content] of Object.entries(cleanedFiles)) {
    // Skip non-source files
    if (!path.match(/\.(ts|tsx|js|jsx|json|html|css|scss)$/)) continue;
    
    // Skip patterns files (they legitimately contain these patterns for detection)
    if (path.includes('clientProprietaryPatterns') || path.includes('proprietary-patterns')) continue;
    if (path.includes('security-cleaner')) continue;
    
    // Check for any remaining proprietary references with CONTEXTUAL detection
    const criticalPatterns = [
      { 
        pattern: /import\s+[^;]*from\s*['"]@\/integrations\/supabase/g, 
        name: 'Import Supabase auto-généré' 
      },
      { 
        // Only match domains in URL context, not just any text
        pattern: /(?:https?:)?\/\/[^\s'"]*(?:lovable\.app|lovable\.dev|gptengineer\.app)/gi, 
        name: 'URL Lovable' 
      },
      { 
        pattern: /izqveyvcebolrqpqlmho/g, 
        name: 'ID projet Supabase' 
      },
      { 
        // JWT tokens (but not in patterns/test files)
        pattern: /['"]eyJ[A-Za-z0-9_-]{100,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+['"]/g, 
        name: 'Token JWT hardcodé' 
      }];
    
    for (const { pattern, name } of criticalPatterns) {
      // Reset regex lastIndex
      pattern.lastIndex = 0;
      if (pattern.test(content)) {
        remainingIssues.push(`${path}: ${name}`);
        criticalCount++;
      }
    }
  }
  
  return {
    isClean: remainingIssues.length === 0,
    remainingIssues,
    criticalCount,
  };
}

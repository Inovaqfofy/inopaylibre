/**
 * Auth Client Adapter
 * Drop-in replacement for Supabase auth client
 * Generated by InoPay Liberation Pack
 */

interface User {
  id: string;
  email: string;
  email_confirmed_at?: string;
  user_metadata?: Record<string, any>;
}

interface Session {
  access_token: string;
  refresh_token: string;
  expires_in: number;
  user: User;
}

interface AuthResponse {
  data: { user: User | null; session: Session | null };
  error: Error | null;
}

const AUTH_URL = import.meta.env.VITE_AUTH_URL || import.meta.env.VITE_API_URL || '';
const STORAGE_KEY = 'auth_session';

function getStoredSession(): Session | null {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    return stored ? JSON.parse(stored) : null;
  } catch { return null; }
}

function storeSession(session: Session | null): void {
  if (session) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(session));
  } else {
    localStorage.removeItem(STORAGE_KEY);
  }
}

async function fetchAuth(endpoint: string, options: RequestInit = {}): Promise<any> {
  const session = getStoredSession();
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    ...options.headers as Record<string, string>
  };
  
  if (session?.access_token) {
    headers['Authorization'] = 'Bearer ' + session.access_token;
  }
  
  const res = await fetch(AUTH_URL + '/auth/v1' + endpoint, { ...options, headers });
  return res.json();
}

export const authClient = {
  async signUp(email: string, password: string, metadata?: Record<string, any>): Promise<AuthResponse> {
    try {
      const data = await fetchAuth('/signup', {
        method: 'POST',
        body: JSON.stringify({ email, password, data: metadata })
      });
      
      if (data.error) return { data: { user: null, session: null }, error: new Error(data.error) };
      
      const session: Session = {
        access_token: data.access_token,
        refresh_token: data.refresh_token,
        expires_in: data.expires_in,
        user: data.user
      };
      
      storeSession(session);
      return { data: { user: data.user, session }, error: null };
    } catch (error) {
      return { data: { user: null, session: null }, error: error as Error };
    }
  },

  async signInWithPassword(email: string, password: string): Promise<AuthResponse> {
    try {
      const data = await fetchAuth('/token', {
        method: 'POST',
        body: JSON.stringify({ email, password, grant_type: 'password' })
      });
      
      if (data.error) return { data: { user: null, session: null }, error: new Error(data.error) };
      
      const session: Session = {
        access_token: data.access_token,
        refresh_token: data.refresh_token,
        expires_in: data.expires_in,
        user: data.user
      };
      
      storeSession(session);
      return { data: { user: data.user, session }, error: null };
    } catch (error) {
      return { data: { user: null, session: null }, error: error as Error };
    }
  },

  async signOut(): Promise<{ error: Error | null }> {
    try {
      await fetchAuth('/logout', { method: 'POST' });
      storeSession(null);
      return { error: null };
    } catch (error) {
      storeSession(null);
      return { error: error as Error };
    }
  },

  async getUser(): Promise<{ data: { user: User | null }; error: Error | null }> {
    try {
      const session = getStoredSession();
      if (!session) return { data: { user: null }, error: null };
      
      const data = await fetchAuth('/user');
      if (data.error) return { data: { user: null }, error: new Error(data.error) };
      
      return { data: { user: data }, error: null };
    } catch (error) {
      return { data: { user: null }, error: error as Error };
    }
  },

  async getSession(): Promise<{ data: { session: Session | null }; error: Error | null }> {
    const session = getStoredSession();
    return { data: { session }, error: null };
  },

  onAuthStateChange(callback: (event: string, session: Session | null) => void): { data: { subscription: { unsubscribe: () => void } } } {
    const session = getStoredSession();
    callback(session ? 'SIGNED_IN' : 'SIGNED_OUT', session);
    
    // Listen for storage changes (cross-tab sync)
    const handler = (e: StorageEvent) => {
      if (e.key === STORAGE_KEY) {
        const newSession = e.newValue ? JSON.parse(e.newValue) : null;
        callback(newSession ? 'SIGNED_IN' : 'SIGNED_OUT', newSession);
      }
    };
    
    window.addEventListener('storage', handler);
    return { data: { subscription: { unsubscribe: () => window.removeEventListener('storage', handler) } } };
  }
};

// Export for compatibility with existing code
export const supabase = { auth: authClient };
export default authClient;
